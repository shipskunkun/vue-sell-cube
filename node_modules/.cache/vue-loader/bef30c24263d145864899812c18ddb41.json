{"remainingRequest":"/Users/leeco/Documents/vue-sell-cube/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/leeco/Documents/vue-sell-cube/node_modules/cube-ui/src/components/date-picker/date-picker.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/leeco/Documents/vue-sell-cube/node_modules/cube-ui/src/components/date-picker/date-picker.vue","mtime":499162500000},{"path":"/Users/leeco/Documents/vue-sell-cube/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/leeco/Documents/vue-sell-cube/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/leeco/Documents/vue-sell-cube/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/leeco/Documents/vue-sell-cube/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/leeco/Documents/vue-sell-cube/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport visibilityMixin from '../../common/mixins/visibility'\nimport popupMixin from '../../common/mixins/popup'\nimport pickerMixin from '../../common/mixins/picker'\nimport localeMixin from '../../common/mixins/locale'\nimport { deepAssign, findIndex } from '../../common/helpers/util'\nimport { computeNatureMaxDay, formatType } from '../../common/lang/date'\n\nconst COMPONENT_NAME = 'cube-date-picker'\nconst EVENT_SELECT = 'select'\nconst EVENT_CANCEL = 'cancel'\nconst EVENT_CHANGE = 'change'\n\nconst TYPE_LIST = ['year', 'month', 'date', 'hour', 'minute', 'second']\nconst NATURE_BOUNDARY_MAP = {\n  month: {\n    natureMin: 1,\n    natureMax: 12\n  },\n  date: {\n    natureMin: 1,\n    natureMax: 31\n  },\n  hour: {\n    natureMin: 0,\n    natureMax: 23\n  },\n  minute: {\n    natureMin: 0,\n    natureMax: 59\n  },\n  second: {\n    natureMin: 0,\n    natureMax: 59\n  }\n}\n\nconst DEFAULT_FORMAT = {\n  year: 'YYYY',\n  month: 'M',\n  date: 'D',\n  hour: 'hh',\n  minute: 'mm',\n  second: 'ss'\n}\n\nexport default {\n  name: COMPONENT_NAME,\n  mixins: [visibilityMixin, popupMixin, pickerMixin, localeMixin],\n  props: {\n    min: {\n      type: [Date, Array],\n      default() {\n        return new Date(2010, 1, 1)\n      }\n    },\n    max: {\n      type: [Date, Array],\n      default() {\n        return new Date(2020, 12, 31)\n      }\n    },\n    startColumn: {\n      type: String,\n      default() {\n        return 'year'\n      }\n    },\n    columnCount: {\n      type: Number,\n      default: 3\n    },\n    format: {\n      type: Object,\n      default() {\n        return {}\n      }\n    },\n    value: {\n      type: [Date, Array],\n      default() {\n        return this.min\n      }\n    },\n    columnOrder: {\n      type: Array,\n      default() {\n        return ['year', 'month', 'date', 'hour', 'minute', 'second']\n      }\n    }\n  },\n  computed: {\n    formatConfig() {\n      const formatConfig = Object.assign({}, DEFAULT_FORMAT)\n      deepAssign(formatConfig, this.format)\n\n      return formatConfig\n    },\n    natureRangeCache() {\n      const natureRangeCache = {\n        hour: [],\n        minute: [],\n        second: []\n      }\n\n      Object.keys(natureRangeCache).forEach((key) => {\n        natureRangeCache[key] = this._range(key, NATURE_BOUNDARY_MAP[key].natureMin, NATURE_BOUNDARY_MAP[key].natureMax)\n      })\n\n      return natureRangeCache\n    },\n    startIndex() {\n      const startIndex = TYPE_LIST.indexOf(this.startColumn)\n      return startIndex < 0 ? 0 : startIndex\n    },\n    minArray() {\n      return this.min instanceof Date\n              ? dateToArray(this.min).slice(this.startIndex, this.startIndex + this.columnCount)\n              : this.min\n    },\n    maxArray() {\n      return this.max instanceof Date\n              ? dateToArray(this.max).slice(this.startIndex, this.startIndex + this.columnCount)\n              : this.max\n    },\n    valueArray() {\n      return this.value instanceof Date\n              ? dateToArray(this.value).slice(this.startIndex, this.startIndex + this.columnCount)\n              : this.value\n    },\n    data() {\n      const data = []\n      this._generateData(this.startIndex, 0, data)\n      return data\n    },\n    selectedIndex() {\n      const selectedIndex = []\n      let data = this.data\n      let index\n\n      for (let i = 0; i < this.columnCount && i < 6 - this.startIndex; i++) {\n        index = findIndex(data, (item) => {\n          return this.valueArray[i] && item.value === this.valueArray[i]\n        })\n        selectedIndex[i] = index !== -1 ? index : 0\n        data = data[selectedIndex[i]] && data[selectedIndex[i]].children\n      }\n\n      return selectedIndex\n    }\n  },\n  methods: {\n    _select(selectedVal, selectedIndex, selectedText) {\n      this.$emit(EVENT_SELECT, this._arrayToDate(selectedVal), selectedVal, selectedText)\n    },\n    _cancel() {\n      this.$emit(EVENT_CANCEL)\n    },\n    _change(i, newIndex) {\n      this.$emit(EVENT_CHANGE, i, newIndex)\n    },\n    _generateData(i, count, item) {\n      if (count === 0) {\n        const min = i === 0 ? this.minArray[0] : Math.max(this.minArray[0], NATURE_BOUNDARY_MAP[TYPE_LIST[i]].natureMin)\n        const max = i === 0 ? this.maxArray[0] : Math.min(this.maxArray[0], NATURE_BOUNDARY_MAP[TYPE_LIST[i]].natureMax)\n        item.push.apply(item, this._range(TYPE_LIST[i], min, max, true, true))\n      } else {\n        if (i < 3 || item.isMin || item.isMax) {\n          const natureMax = i === 2 ? computeNatureMaxDay(item.value, item.year) : NATURE_BOUNDARY_MAP[TYPE_LIST[i]].natureMax\n          const min = item.isMin ? Math.max(this.minArray[count], NATURE_BOUNDARY_MAP[TYPE_LIST[i]].natureMin) : NATURE_BOUNDARY_MAP[TYPE_LIST[i]].natureMin\n          const max = item.isMax ? Math.min(this.maxArray[count], natureMax) : natureMax\n\n          const storageYear = i === 1 && this.startIndex === 0 && this.columnCount >= 3 && item.value\n          item.children = this._range(TYPE_LIST[i], min, max, item.isMin, item.isMax, storageYear)\n        } else {\n          item.children = this.natureRangeCache[TYPE_LIST[i]]\n        }\n      }\n      if (count < this.columnCount - 1 && i < 5) {\n        (item.children || item).forEach(subItem => {\n          (!subItem.children || subItem.isMin || subItem.isMax) && this._generateData(i + 1, count + 1, subItem)\n        })\n      }\n    },\n    _arrayToDate(selectedVal) {\n      const args = []\n      const defaultDateArray = dateToArray(new Date(0))\n\n      for (let i = 0; i < 6; i++) {\n        if (i < this.startIndex) {\n          args[i] = defaultDateArray[i]\n        } else if (i >= this.startIndex + this.columnCount) {\n          args[i] = NATURE_BOUNDARY_MAP[TYPE_LIST[i]].natureMin\n        } else {\n          args[i] = selectedVal[i - this.startIndex]\n        }\n      }\n      // Month need to subtract 1.\n      args[1]--\n\n      return new Date(...args)\n    },\n    _range(type, min, max, fatherIsMin, fatherIsMax, year = 0) {\n      if (!this._rangeCache) {\n        this._rangeCache = {}\n      }\n      const k = type + year + min + max + fatherIsMin + fatherIsMax\n      if (this._rangeCache[k]) {\n        return this._rangeCache[k]\n      }\n      const arr = []\n      const format = this.formatConfig[type]\n      for (let i = min; i <= max; i++) {\n        const object = {\n          text: formatType(type, format, i, 'i'),\n          value: i,\n          order: this.columnOrder.indexOf(type)\n        }\n\n        if (fatherIsMin && i === min) object.isMin = true\n        if (fatherIsMax && i === max) object.isMax = true\n        if (year) object.year = year\n\n        arr.push(object)\n      }\n      this._rangeCache[k] = arr\n      return arr\n    }\n  }\n}\n\nfunction dateToArray(date) {\n  return [date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()]\n}\n",{"version":3,"sources":["date-picker.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA","file":"date-picker.vue","sourceRoot":"node_modules/cube-ui/src/components/date-picker","sourcesContent":["<template>\n  <cube-cascade-picker\n    v-model=\"isVisible\"\n    :data=\"data\"\n    :selected-index=\"selectedIndex\"\n    :title=\"title\"\n    :subtitle=\"subtitle\"\n    :cancel-txt=\"_cancelTxt\"\n    :confirm-txt=\"_confirmTxt\"\n    :swipe-time=\"swipeTime\"\n    :z-index=\"zIndex\"\n    :mask-closable=\"maskClosable\"\n    @select=\"_select\"\n    @cancel=\"_cancel\"\n    @change=\"_change\">\n  </cube-cascade-picker>\n</template>\n\n<script>\n  import visibilityMixin from '../../common/mixins/visibility'\n  import popupMixin from '../../common/mixins/popup'\n  import pickerMixin from '../../common/mixins/picker'\n  import localeMixin from '../../common/mixins/locale'\n  import { deepAssign, findIndex } from '../../common/helpers/util'\n  import { computeNatureMaxDay, formatType } from '../../common/lang/date'\n\n  const COMPONENT_NAME = 'cube-date-picker'\n  const EVENT_SELECT = 'select'\n  const EVENT_CANCEL = 'cancel'\n  const EVENT_CHANGE = 'change'\n\n  const TYPE_LIST = ['year', 'month', 'date', 'hour', 'minute', 'second']\n  const NATURE_BOUNDARY_MAP = {\n    month: {\n      natureMin: 1,\n      natureMax: 12\n    },\n    date: {\n      natureMin: 1,\n      natureMax: 31\n    },\n    hour: {\n      natureMin: 0,\n      natureMax: 23\n    },\n    minute: {\n      natureMin: 0,\n      natureMax: 59\n    },\n    second: {\n      natureMin: 0,\n      natureMax: 59\n    }\n  }\n\n  const DEFAULT_FORMAT = {\n    year: 'YYYY',\n    month: 'M',\n    date: 'D',\n    hour: 'hh',\n    minute: 'mm',\n    second: 'ss'\n  }\n\n  export default {\n    name: COMPONENT_NAME,\n    mixins: [visibilityMixin, popupMixin, pickerMixin, localeMixin],\n    props: {\n      min: {\n        type: [Date, Array],\n        default() {\n          return new Date(2010, 1, 1)\n        }\n      },\n      max: {\n        type: [Date, Array],\n        default() {\n          return new Date(2020, 12, 31)\n        }\n      },\n      startColumn: {\n        type: String,\n        default() {\n          return 'year'\n        }\n      },\n      columnCount: {\n        type: Number,\n        default: 3\n      },\n      format: {\n        type: Object,\n        default() {\n          return {}\n        }\n      },\n      value: {\n        type: [Date, Array],\n        default() {\n          return this.min\n        }\n      },\n      columnOrder: {\n        type: Array,\n        default() {\n          return ['year', 'month', 'date', 'hour', 'minute', 'second']\n        }\n      }\n    },\n    computed: {\n      formatConfig() {\n        const formatConfig = Object.assign({}, DEFAULT_FORMAT)\n        deepAssign(formatConfig, this.format)\n\n        return formatConfig\n      },\n      natureRangeCache() {\n        const natureRangeCache = {\n          hour: [],\n          minute: [],\n          second: []\n        }\n\n        Object.keys(natureRangeCache).forEach((key) => {\n          natureRangeCache[key] = this._range(key, NATURE_BOUNDARY_MAP[key].natureMin, NATURE_BOUNDARY_MAP[key].natureMax)\n        })\n\n        return natureRangeCache\n      },\n      startIndex() {\n        const startIndex = TYPE_LIST.indexOf(this.startColumn)\n        return startIndex < 0 ? 0 : startIndex\n      },\n      minArray() {\n        return this.min instanceof Date\n                ? dateToArray(this.min).slice(this.startIndex, this.startIndex + this.columnCount)\n                : this.min\n      },\n      maxArray() {\n        return this.max instanceof Date\n                ? dateToArray(this.max).slice(this.startIndex, this.startIndex + this.columnCount)\n                : this.max\n      },\n      valueArray() {\n        return this.value instanceof Date\n                ? dateToArray(this.value).slice(this.startIndex, this.startIndex + this.columnCount)\n                : this.value\n      },\n      data() {\n        const data = []\n        this._generateData(this.startIndex, 0, data)\n        return data\n      },\n      selectedIndex() {\n        const selectedIndex = []\n        let data = this.data\n        let index\n\n        for (let i = 0; i < this.columnCount && i < 6 - this.startIndex; i++) {\n          index = findIndex(data, (item) => {\n            return this.valueArray[i] && item.value === this.valueArray[i]\n          })\n          selectedIndex[i] = index !== -1 ? index : 0\n          data = data[selectedIndex[i]] && data[selectedIndex[i]].children\n        }\n\n        return selectedIndex\n      }\n    },\n    methods: {\n      _select(selectedVal, selectedIndex, selectedText) {\n        this.$emit(EVENT_SELECT, this._arrayToDate(selectedVal), selectedVal, selectedText)\n      },\n      _cancel() {\n        this.$emit(EVENT_CANCEL)\n      },\n      _change(i, newIndex) {\n        this.$emit(EVENT_CHANGE, i, newIndex)\n      },\n      _generateData(i, count, item) {\n        if (count === 0) {\n          const min = i === 0 ? this.minArray[0] : Math.max(this.minArray[0], NATURE_BOUNDARY_MAP[TYPE_LIST[i]].natureMin)\n          const max = i === 0 ? this.maxArray[0] : Math.min(this.maxArray[0], NATURE_BOUNDARY_MAP[TYPE_LIST[i]].natureMax)\n          item.push.apply(item, this._range(TYPE_LIST[i], min, max, true, true))\n        } else {\n          if (i < 3 || item.isMin || item.isMax) {\n            const natureMax = i === 2 ? computeNatureMaxDay(item.value, item.year) : NATURE_BOUNDARY_MAP[TYPE_LIST[i]].natureMax\n            const min = item.isMin ? Math.max(this.minArray[count], NATURE_BOUNDARY_MAP[TYPE_LIST[i]].natureMin) : NATURE_BOUNDARY_MAP[TYPE_LIST[i]].natureMin\n            const max = item.isMax ? Math.min(this.maxArray[count], natureMax) : natureMax\n\n            const storageYear = i === 1 && this.startIndex === 0 && this.columnCount >= 3 && item.value\n            item.children = this._range(TYPE_LIST[i], min, max, item.isMin, item.isMax, storageYear)\n          } else {\n            item.children = this.natureRangeCache[TYPE_LIST[i]]\n          }\n        }\n        if (count < this.columnCount - 1 && i < 5) {\n          (item.children || item).forEach(subItem => {\n            (!subItem.children || subItem.isMin || subItem.isMax) && this._generateData(i + 1, count + 1, subItem)\n          })\n        }\n      },\n      _arrayToDate(selectedVal) {\n        const args = []\n        const defaultDateArray = dateToArray(new Date(0))\n\n        for (let i = 0; i < 6; i++) {\n          if (i < this.startIndex) {\n            args[i] = defaultDateArray[i]\n          } else if (i >= this.startIndex + this.columnCount) {\n            args[i] = NATURE_BOUNDARY_MAP[TYPE_LIST[i]].natureMin\n          } else {\n            args[i] = selectedVal[i - this.startIndex]\n          }\n        }\n        // Month need to subtract 1.\n        args[1]--\n\n        return new Date(...args)\n      },\n      _range(type, min, max, fatherIsMin, fatherIsMax, year = 0) {\n        if (!this._rangeCache) {\n          this._rangeCache = {}\n        }\n        const k = type + year + min + max + fatherIsMin + fatherIsMax\n        if (this._rangeCache[k]) {\n          return this._rangeCache[k]\n        }\n        const arr = []\n        const format = this.formatConfig[type]\n        for (let i = min; i <= max; i++) {\n          const object = {\n            text: formatType(type, format, i, 'i'),\n            value: i,\n            order: this.columnOrder.indexOf(type)\n          }\n\n          if (fatherIsMin && i === min) object.isMin = true\n          if (fatherIsMax && i === max) object.isMax = true\n          if (year) object.year = year\n\n          arr.push(object)\n        }\n        this._rangeCache[k] = arr\n        return arr\n      }\n    }\n  }\n\n  function dateToArray(date) {\n    return [date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()]\n  }\n</script>\n"]}]}